{
    "data": {
        "markdownRemark": {
            "html": "<p>Sourced from:</p>\n<p><a href=\"http://www.christianalfoni.com/articles/2016_04_06_CycleJS-driven-by-state#state-store\">http://www.christianalfoni.com/articles/2016_04_06_CycleJS-driven-by-state#state-store</a></p>\n<p>André Staltz has been developing an interesting project called CycleJS that is based\non the philosophy that applications are just IO with inputs typically being interactions\nvia keyboard, mouse etc and the outputs being typically UI such as DOM. The whole\nidea gels well with the Observables. CycleJS revolves around Observables and hence the\nname what goes in, comes back out and back around again.</p>\n<p>Observables being based on inputs and outputs are powerful because of how you can\ntransform and control the flow of data/information going through the observable.</p>\n<p>A simple example of this transformation and control could be a reaction to a click that\nwill increase a count after 200ms</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-none\"><code>// With plain JS\nlet count = 0;\ndocument.querySelector('#button').addEventListener('click', () => {\nsetTimeout(() => ++count, 200);\n});\n\n// With Observable\nObservable.fromEvent(document.querySelector('#button'), 'click')\n.delay(200)\n.scan(count => ++count, 0);</code></pre>\n      </div>\n<p>An observable approach means more expressive code, felxible and you can achieve\nsome amazing stuff with little code.</p>\n<p>Pure functions are simply input and outputs</p>\n<p>A pure function doesn’t depend on and doesn’t modify the states of variables out of its scope.</p>\n<p>Concretely, that means a pure function always returns the same result given same parameters. Its execution doesn’t depend on the state of the system.</p>\n<p>Pure functions are a pillar of functional programming.</p>\n<p><a href=\"http://www.nicoespeon.com/en/2015/01/pure-functions-javascript/\">http://www.nicoespeon.com/en/2015/01/pure-functions-javascript/</a></p>\n<p>This makes your code less error prone and it is easier to test. But the question to answer is: “How can you actually build an application with this approach?”</p>",
            "frontmatter": {
                "title": "State"
            }
        }
    },
    "pathContext": {
        "slug": "/guides/cyclejs/state/"
    }
}